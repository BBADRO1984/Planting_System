
import streamlit as st
import matplotlib.pyplot as plt
from matplotlib.patches import FancyBboxPatch
from matplotlib.backends.backend_pdf import PdfPages
from PIL import Image
import base64, io, os
import pandas as pd
from datetime import datetime

# ==========================
# Configuraci√≥n fija (sin UI)
# ==========================
EMPRESA_NOMBRE = "GDM SEEDS"             # <--- Cambiar por el nombre real si deseas
TITULO_PORTADA = "Dise√±o de Siembra"     # <--- Cambiar si deseas otro t√≠tulo
FONDO_IMG_PATH = "assets/company_bg.jpg" # <--- Imagen de fondo corporativo

# ==========================
# Language strings (EN / ES)
# ==========================
LANG = {
    'es': {
        'term': "Dise√±o",
        'app_title': "üå± Dise√±ador de Sistema de Siembra",
        'app_subtitle': "### Configura tu ensayo y obt√©n la organizaci√≥n correcta de sobres",
        'trial_type': "Tipo de Ensayo",
        'srow': "SROW",
        'mrow': "MROW",
        'entries': "N√∫mero de Entradas (M)",
        'ranges': "N√∫mero de Rangos por Entrada (N)",
        'generate': "Generar Sistema de Siembra",
        'header_srow': "SROW ‚Äì Sistema de Siembra",
        'header_mrow': "MROW ‚Äì Sistema de Siembra",
        'overview': "üèûÔ∏è Vista general de {term}",
        'assignments': "üßë‚Äçüåæ Asignaciones por persona",
        'export': "üñ®Ô∏è Exportar / Imprimir",
        'download_png': "Descargar {term} (PNG)",
        'download_pdf': "Descargar {term} (PDF)",
        'download_csv': "Descargar orden de cajas (CSV)",
        'download_pptx': "Descargar presentaci√≥n (PPTX)",
        'download_boxes_pdf': "Descargar vistas de cajas (PDF)",
        'pptx_hint': "üìÑ Si deseas PPTX, aseg√∫rate de tener instalado `python-pptx`.",
        'start_label': "Inicio\nE1/R1",
        'go': "GO (‚Üë)",
        'return': "RETURN (‚Üì)",
        'range_1_to_n': "Rango 1 ‚Üí {n}",
        'range_n_to_1': "Rango {n} ‚Üí 1",
        'entry': "Entrada {e}",
        'envelope_order': "**Orden de sobres:**",
        'box_label': "Caja {caja} - {desc}",
        'grid_title': "{tipo} {term} ‚Äì {m} Entradas √ó {n} Rangos",
        # Portada
        'cover_company': "Empresa:",
        'cover_trial': "Ensayo:",
        'cover_entries': "Entradas (M):",
        'cover_ranges': "Rangos (N):",
        'cover_date': "Fecha:",
        'cover_author': "Generado por:",
        # Personas
        'person_a_rows': "Persona A (Filas 1-2)",
        'person_b_rows': "Persona B (Filas 3-4)",
        'person_1_rows': "Persona 1 (Filas 1-2)",
        'person_2_rows': "Persona 2 (Filas 3-4)",
        'person_3_rows': "Persona 3 (Filas 5-6)",
        'person_4_rows': "Persona 4 (Filas 7-8)",
        # Idioma
        'language_label': "Idioma / Language",
        'lang_es': "Espa√±ol",
        'lang_en': "English",
        # Etiqueta corta para el badge/pie
        'top_envelope': "Sobre superior",
    },
    'en': {
        'term': "Design",
        'app_title': "üå± Planting System Designer",
        'app_subtitle': "### Configure your trial and get proper envelope organization",
        'trial_type': "Trial Type",
        'srow': "SROW",
        'mrow': "MROW",
        'entries': "Number of Entries (M)",
        'ranges': "Number of Ranges per Entry (N)",
        'generate': "Generate Planting System",
        'header_srow': "SROW ‚Äì Planting System",
        'header_mrow': "MROW ‚Äì Planting System",
        'overview': "üèûÔ∏è {term} Overview",
        'assignments': "üßë‚Äçüåæ Person Assignments",
        'export': "üñ®Ô∏è Export / Print",
        'download_png': "Download {term} (PNG)",
        'download_pdf': "Download {term} (PDF)",
        'download_csv': "Download box order (CSV)",
        'download_pptx': "Download presentation (PPTX)",
        'download_boxes_pdf': "Download box views (PDF)",
        'pptx_hint': "üìÑ For PPTX, ensure `python-pptx` is installed.",
        'start_label': "Start\nE1/R1",
        'go': "GO (‚Üë)",
        'return': "RETURN (‚Üì)",
        'range_1_to_n': "Range 1 ‚Üí {n}",
        'range_n_to_1': "Range {n} ‚Üí 1",
        'entry': "Entry {e}",
        'envelope_order': "**Envelope Order:**",
        'box_label': "Box {caja} - {desc}",
        'grid_title': "{tipo} {term} ‚Äì {m} Entries √ó {n} Ranges",
        # Cover
        'cover_company': "Company:",
        'cover_trial': "Trial:",
        'cover_entries': "Entries (M):",
        'cover_ranges': "Ranges (N):",
        'cover_date': "Date:",
        'cover_author': "Generated by:",
        # Persons
        'person_a_rows': "Person A (Rows 1-2)",
        'person_b_rows': "Person B (Rows 3-4)",
        'person_1_rows': "Person 1 (Rows 1-2)",
        'person_2_rows': "Person 2 (Rows 3-4)",
        'person_3_rows': "Person 3 (Rows 5-6)",
        'person_4_rows': "Person 4 (Rows 7-8)",
        # Language
        'language_label': "Idioma / Language",
        'lang_es': "Espa√±ol",
        'lang_en': "English",
        # Short label
        'top_envelope': "Top envelope",
    }
}

def t(key, lang='es', **kwargs):
    s = LANG[lang][key]
    return s.format(**kwargs) if kwargs else s

# ==========================
# Fondo corporativo (CSS)
# ==========================
def set_background(image_path: str):
    """Clear UI containers; show company background as-is."""
    if os.path.exists(image_path):
        with open(image_path, "rb") as f:
            b64 = base64.b64encode(f.read()).decode()
        bg_css = f'background-image: url("data:image/jpg;base64,{b64}");'
    else:
        # Fallback gradient if image not found
        bg_css = 'background: linear-gradient(135deg, #e6f0ff 0%, #ffffff 50%, #f2f8ff 100%);'

    css = f"""
    <style>
    /* App background */
    .stApp {{
        {bg_css}
        background-size: cover;
        background-position: center;
        background-attachment: fixed;
    }}

    /* Remove white backgrounds from containers */
    .block-container, .stMarkdown, [data-baseweb="card"], .stSidebar, .stButton button {{
        background: transparent !important;
        box-shadow: none !important;
    }}

    /* Tighten base spacing */
    .block-container {{
        padding-top: 1rem;
    }}

    /* Improve text legibility on busy images */
    html, body, .stApp, .block-container, p, h1, h2, h3, h4, h5, h6, span, label {{
        color: #111 !important;
        text-shadow: 0 1px 2px rgba(255,255,255,0.4);
    }}

    /* Inputs: keep clean borders, transparent backdrop */
    .stTextInput > div > div > input,
    .stNumberInput input,
    .stSelectbox [data-baseweb="select"],
    .stDownloadButton button {{
        background: rgba(255,255,255,0.35) !important;
        backdrop-filter: blur(4px);
        border: 1px solid rgba(0,0,0,0.1);
    }}

    /* Sidebar transparent as well */
    .stSidebar > div {{
        background: transparent !important;
    }}
    </style>
    """
    st.markdown(css, unsafe_allow_html=True)

# ==========================
# Serpentina por entrada (sin cambios de l√≥gica)
# ==========================
def srow_person_direction_for_entry(e: int):
    """
    SROW: patr√≥n de 8 entradas:
    GO (‚Üë): 1-2 -> A, 3-4 -> B; RETURN (‚Üì): 5-6 -> B, 7-8 -> A
    """
    pos = (e - 1) % 8 + 1
    person = 'A' if pos in (1, 2, 7, 8) else 'B'
    direction_up = pos <= 4
    return person, direction_up

def mrow_person_direction_for_entry(e: int):
    """
    MROW: patr√≥n de 16 entradas:
    GO (‚Üë, 1-8): 1-2 -> 1, 3-4 -> 2, 5-6 -> 3, 7-8 -> 4
    RETURN (‚Üì, 9-16): 9-10 -> 4, 11-12 -> 3, 13-14 -> 2, 15-16 -> 1
    """
    pos = (e - 1) % 16 + 1
    if pos <= 8:
        person = str(((pos - 1) // 2) + 1)  # 1..4
        direction_up = True
    else:
        person = str(4 - ((pos - 9) // 2))  # 4..1
        direction_up = False
    return person, direction_up

# ==========================
# Dise√±o (rejilla) M x N
# ==========================
def crear_rejilla_completa(tipo_ensayo, entradas, rangos, lang, term_label, marcar_inicio=True):
    fig, ax = plt.subplots(figsize=_figsize_auto(entradas, rangos))
    cell_w, cell_h = 1.0, 1.0

    for r in range(1, rangos + 1):
        for e in range(1, entradas + 1):
            x = (e - 1) * cell_w
            y = (r - 1) * cell_h

            if tipo_ensayo == "SROW":
                person, direction_up = srow_person_direction_for_entry(e)
                person_label = f"P{person}"
            else:
                person, direction_up = mrow_person_direction_for_entry(e)
                person_label = f"P{person}"

            rect = FancyBboxPatch((x, y), cell_w, cell_h,
                                  boxstyle="round,pad=0.02",
                                  facecolor='white', edgecolor='#cccccc', linewidth=0.8)
            ax.add_patch(rect)

            ax.text(x + cell_w * 0.5, y + cell_h * 0.60, person_label,
                    ha='center', va='center', fontsize=_font_auto(entradas, rangos), fontweight='bold')

            arrow_x = x + cell_w * 0.5
            arrow_y = y + cell_h * 0.35
            arrow_dy = cell_h * 0.22
            if direction_up:
                ax.arrow(arrow_x, arrow_y, 0, arrow_dy,
                         head_width=cell_w * 0.12, head_length=cell_h * 0.10,
                         fc='#27ae60', ec='#27ae60', linewidth=1.5)
            else:
                ax.arrow(arrow_x, arrow_y, 0, -arrow_dy,
                         head_width=cell_w * 0.12, head_length=cell_h * 0.10,
                         fc='#e74c3c', ec='#e74c3c', linewidth=1.5)

    ax.set_xticks([(e - 0.5) * cell_w for e in range(1, entradas + 1)])
    ax.set_xticklabels([f"E{e}" for e in range(1, entradas + 1)],
                       rotation=90, fontsize=_font_auto(entradas, rangos))
    ax.set_yticks([(r - 0.5) * cell_h for r in range(1, rangos + 1)])
    ax.set_yticklabels([f"R{r}" for r in range(1, rangos + 1)],
                       fontsize=_font_auto(entradas, rangos))

    if marcar_inicio and entradas >= 1 and rangos >= 1:
        ax.text(0 + cell_w * 0.1, 0 + cell_h * 0.1, t('start_label', lang),
                color="#2ecc71", fontsize=_font_auto(entradas, rangos),
                ha='left', va='bottom', fontweight='bold')

    ax.set_xlim(0, entradas * cell_w)
    ax.set_ylim(0, rangos * cell_h)
    ax.set_aspect('equal')
    ax.grid(False)
    ax.set_title(t('grid_title', lang, term=term_label, tipo=tipo_ensayo, m=entradas, n=rangos), fontsize=12, pad=12)
    plt.tight_layout()
    return fig

def _figsize_auto(entradas, rangos):
    w_per, h_per = 0.35, 0.35
    max_w, max_h = 22, 16
    return (min(max_w, max(6, entradas * w_per)),
            min(max_h, max(4, rangos * h_per)))

def _font_auto(entradas, rangos):
    if entradas > 40 or rangos > 40:
        return 6
    elif entradas > 25 or rangos > 25:
        return 8
    return 10

# ==========================
# Cajas (c√°lculo) ‚Äî sin cambios de l√≥gica
# ==========================
def calcular_cajas_srow(entradas, rangos):
    cajas_por_bloque = (entradas + 3) // 8
    cajas_A, cajas_B = [], []
    for box_num in range(cajas_por_bloque):
        inicio = box_num * 8 + 1
        go_A = [inicio, inicio + 1]
        ret_A = [inicio + 6, inicio + 7]
        go_B = [inicio + 2, inicio + 3]
        ret_B = [inicio + 4, inicio + 5]
        go_A = [e for e in go_A if e <= entradas]; ret_A = [e for e in ret_A if e <= entradas]
        go_B = [e for e in go_B if e <= entradas]; ret_B = [e for e in ret_B if e <= entradas]
        if go_A or ret_A:
            cajas_A.append({'caja': box_num + 1, 'go_entradas': go_A, 'return_entradas': ret_A, 'descripcion': f'Pasada {box_num + 1}'})
        if go_B or ret_B:
            cajas_B.append({'caja': box_num + 1, 'go_entradas': go_B, 'return_entradas': ret_B, 'descripcion': f'Pasada {box_num + 1}'})
    return {'A': cajas_A, 'B': cajas_B}

def calcular_cajas_mrow(entradas, rangos):
    cajas_por_bloque = (entradas + 7) // 16
    personas = {'1': [], '2': [], '3': [], '4': []}
    for box_num in range(cajas_por_bloque):
        base = box_num * 16
        e1, r1 = [base + 1, base + 2], [base + 15, base + 16]
        e2, r2 = [base + 3, base + 4], [base + 13, base + 14]
        e3, r3 = [base + 5, base + 6], [base + 11, base + 12]
        e4, r4 = [base + 7, base + 8], [base + 9, base + 10]
        e1 = [e for e in e1 if e <= entradas]; r1 = [e for e in r1 if e <= entradas]
        e2 = [e for e in e2 if e <= entradas]; r2 = [e for e in r2 if e <= entradas]
        e3 = [e for e in e3 if e <= entradas]; r3 = [e for e in r3 if e <= entradas]
        e4 = [e for e in e4 if e <= entradas]; r4 = [e for e in r4 if e <= entradas]
        if e1 or r1: personas['1'].append({'caja': box_num + 1, 'go_entradas': e1, 'return_entradas': r1, 'descripcion': f'Pasada {box_num + 1}'})
        if e2 or r2: personas['2'].append({'caja': box_num + 1, 'go_entradas': e2, 'return_entradas': r2, 'descripcion': f'Pasada {box_num + 1}'})
        if e3 or r3: personas['3'].append({'caja': box_num + 1, 'go_entradas': e3, 'return_entradas': r3, 'descripcion': f'Pasada {box_num + 1}'})
        if e4 or r4: personas['4'].append({'caja': box_num + 1, 'go_entradas': e4, 'return_entradas': r4, 'descripcion': f'Pasada {box_num + 1}'})
    return personas

# ==========================
# Exportaciones
# ==========================
def fig_to_png_bytes(fig):
    buf = io.BytesIO()
    fig.savefig(buf, format='png', dpi=200, bbox_inches='tight')
    buf.seek(0)
    return buf

def grid_pdf_with_optional_cover(grid_fig, cover_fig=None):
    buf = io.BytesIO()
    with PdfPages(buf) as pdf:
        if cover_fig is not None:
            pdf.savefig(cover_fig, bbox_inches='tight')
            plt.close(cover_fig)
        pdf.savefig(grid_fig, bbox_inches='tight')
    buf.seek(0)
    return buf

def cajas_to_dataframe(dict_cajas, rangos, tipo_ensayo, lang):
    rows = []
    for key, cajas in dict_cajas.items():
        persona_name = _display_person_name(tipo_ensayo, key, lang)
        for c in cajas:
            if c.get('go_entradas'):
                rows.append({
                    'Persona': persona_name,
                    'Caja': c['caja'],
                    'Tipo': t('go', lang),
                    'Entradas': ', '.join(map(str, c['go_entradas'])),
                    'Rango_inicio': 1, 'Rango_fin': rangos
                })
            if c.get('return_entradas'):
                rows.append({
                    'Persona': persona_name,
                    'Caja': c['caja'],
                    'Tipo': t('return', lang),
                    'Entradas': ', '.join(map(str, c['return_entradas'])),
                    'Rango_inicio': rangos, 'Rango_fin': 1
                })
    df = pd.DataFrame(rows)
    tipo_cat = pd.Categorical(df['Tipo'], categories=[t('go', lang), t('return', lang)], ordered=True)
    df = df.assign(_order=tipo_cat).sort_values(['Persona', 'Caja', '_order']).drop(columns=['_order'])
    return df

def dataframe_to_csv_bytes(df):
    buf = io.BytesIO()
    df.to_csv(buf, index=False, encoding='utf-8')
    buf.seek(0)
    return buf

def crear_pptx_bytes(fig_png_bytes, df_cajas, lang):
    try:
        from pptx import Presentation
        from pptx.util import Inches, Pt
    except Exception:
        return None
    prs = Presentation()
    slide1 = prs.slides.add_slide(prs.slide_layouts[5])
    image_stream = io.BytesIO(fig_png_bytes.read())
    slide1.shapes.add_picture(image_stream, Inches(0.5), Inches(0.5), width=Inches(9.0))

    slide2 = prs.slides.add_slide(prs.slide_layouts[5])
    tx = slide2.shapes.add_textbox(Inches(0.5), Inches(0.5), Inches(9.0), Inches(6.0))
    tf = tx.text_frame; tf.clear()
    p = tf.paragraphs[0]
    p.text = t('envelope_order', lang).replace("**", "")
    p.font.name = "Times New Roman"
    try:
        p.font.size = Pt(24)
    except Exception:
        pass
    p.font.bold = True
    for _, row in df_cajas.iterrows():
        par = tf.add_paragraph()
        par.text = f"{row['Persona']} | {t('box_label', lang, caja=row['Caja'], desc='').replace(' - ', ' ').strip()} | {row['Tipo']} | {row['Entradas']} | {row['Rango_inicio']}‚Üí{row['Rango_fin']}"
        par.font.name = "Times New Roman"
        try:
            par.font.size = Pt(12)
        except Exception:
            pass
    out = io.BytesIO(); prs.save(out); out.seek(0)
    return out

def crear_pdf_vistas_cajas(dict_cajas, rangos, tipo_ensayo, lang, cover_fig=None):
    buf = io.BytesIO()
    with PdfPages(buf) as pdf:
        if cover_fig is not None:
            pdf.savefig(cover_fig, bbox_inches='tight')
            plt.close(cover_fig)
        # Orden consistente por persona
        person_order = ['A', 'B'] if tipo_ensayo == "SROW" else ['1', '2', '3', '4']
        for person_key in person_order:
            cajas = dict_cajas.get(person_key, [])
            display_name = _display_person_name(tipo_ensayo, person_key, lang)
            for c in cajas:
                fig = _fig_panel_caja(display_name, c, rangos, lang)
                pdf.savefig(fig, bbox_inches='tight')
                plt.close(fig)
    buf.seek(0)
    return buf

# ==========================
# Portada PDF (limpia; sin repetir regla gen√©rica por caja)
# ==========================
def crear_portada_fig(company, cover_title, tipo_ensayo, entradas, rangos, lang, term_label):
    fig = plt.figure(figsize=(8.5, 11))  # Vertical (Letter/A4 aprox)
    ax = fig.add_axes([0, 0, 1, 1]); ax.axis('off')

    # T√≠tulo y subt√≠tulo
    ax.text(0.06, 0.80, cover_title, fontsize=26, fontweight='bold', ha='left', va='top', color='#2c3e50')
    sub = t('grid_title', lang, term=term_label, tipo=tipo_ensayo, m=entradas, n=rangos)
    ax.text(0.06, 0.75, sub, fontsize=14, ha='left', va='top', color='#34495e')

    # Logo: recorte cuadrado del fondo si existe
    if os.path.exists(FONDO_IMG_PATH):
        try:
            img = Image.open(FONDO_IMG_PATH)
            w, h = img.size
            side = min(w, h)
            left = (w - side)//2; top = (h - side)//2
            crop = img.crop((left, top, left+side, top+side))
            ax_img = fig.add_axes([0.70, 0.75, 0.24, 0.24])  # x,y,w,h
            ax_img.imshow(crop); ax_img.axis('off')
        except Exception:
            pass

    # Caja de metadatos
    box_x, box_y, box_w, box_h = 0.06, 0.42, 0.88, 0.26
    meta = FancyBboxPatch((box_x, box_y), box_w, box_h, boxstyle="round,pad=0.03",
                          facecolor='#f7f9fc', edgecolor='#95a5a6', linewidth=1.2)
    ax.add_patch(meta)

    # L√≠neas metadatos
    line_y = box_y + box_h - 0.06
    def line(text_left, text_right=""):
        nonlocal line_y
        ax.text(box_x + 0.02, line_y, text_left, fontsize=12, ha='left', va='top', color='#2c3e50')
        if text_right:
            ax.text(box_x + box_w - 0.02, line_y, text_right, fontsize=12, ha='right', va='top', color='#2c3e50')
        line_y -= 0.06

    line(f"{t('cover_company', lang)} {company or '-'}")
    line(f"{t('cover_trial', lang)} {tipo_ensayo}")
    line(f"{t('cover_entries', lang)} {entradas}", f"{t('cover_ranges', lang)} {rangos}")
    line(f"{t('cover_date', lang)} {datetime.now().strftime('%Y-%m-%d')}",
         f"{t('cover_author', lang)} Bashar Badro")

    # Nota breve de serpentina (no repite regla por caja)
    ax.text(0.06, 0.10,
            ("Serpentina: GO (‚Üë) / RETURN (‚Üì) por grupos de entradas."
             if lang == 'es'
             else "Serpentine: GO (‚Üë) / RETURN (‚Üì) by entry groups."),
            fontsize=10, ha='left', va='bottom', color='#2c3e50')

    return fig

# ==========================
# UI helpers
# ==========================
def _display_person_name(tipo_ensayo, person_key, lang):
    if tipo_ensayo == "SROW":
        return t('person_a_rows', lang) if person_key == 'A' else t('person_b_rows', lang)
    else:
        mapping = {'1': 'person_1_rows', '2': 'person_2_rows', '3': 'person_3_rows', '4': 'person_4_rows'}
        return t(mapping[person_key], lang)

def _fig_panel_caja(nombre_persona, caja_info, rangos, lang):
    """
    Dibuja el panel por caja y marca visualmente el 'Sobre superior':
    - GO: menor entrada del par
    - RETURN: mayor entrada del par
    Esta funci√≥n se usa tanto en la app como en el PDF de vistas de cajas.
    """
    # +0.2 en altura para espacio del marcador
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(6.8, 2.4))
    fig.suptitle(f"{nombre_persona} ‚Äî " + t('box_label', lang, caja=caja_info['caja'], desc=caja_info['descripcion']),
                 fontsize=11, fontweight='bold')

    # ---------- GO (‚Üë) ----------
    if caja_info['go_entradas']:
        ax1.text(0.5, 0.86, t('go', lang), ha='center', va='center',
                 fontweight='bold', fontsize=12, color='#27ae60')
        ax1.text(0.5, 0.68, t('range_1_to_n', lang, n=rangos), ha='center', va='center',
                 fontsize=10, color='#27ae60')

        # Sobre superior en GO: menor entrada
        top_go = min(caja_info['go_entradas'])

        # Entradas GO
        for i, e in enumerate(caja_info['go_entradas']):
            y = 0.38 - i * 0.26
            ax1.add_patch(FancyBboxPatch((0.18, y-0.1), 0.64, 0.16, facecolor='white', edgecolor='#cccccc'))
            ax1.text(0.5, y-0.02, t('entry', lang, e=e), ha='center', va='center',
                     fontweight='bold', fontsize=11)
            ax1.arrow(0.5, y-0.16, 0, 0.06, head_width=0.08, head_length=0.02,
                      fc='#27ae60', ec='#27ae60', linewidth=2)

            # Badge "Sobre superior" / "Top envelope" en la entrada marcada
            if e == top_go:
                ax1.text(0.20, y+0.06, t('top_envelope', lang),
                         ha='left', va='bottom', fontsize=8, fontweight='bold',
                         color='#27ae60',
                         bbox=dict(boxstyle='round,pad=0.2', facecolor='#fffbe6', edgecolor='#f1c40f'))

    ax1.set_xlim(0, 1); ax1.set_ylim(-0.40, 1); ax1.set_aspect('equal'); ax1.axis('off')

    # ---------- RETURN (‚Üì) ----------
    if caja_info['return_entradas']:
        ax2.text(0.5, 0.86, t('return', lang), ha='center', va='center',
                 fontweight='bold', fontsize=12, color='#e74c3c')
        ax2.text(0.5, 0.68, t('range_n_to_1', lang, n=rangos), ha='center', va='center',
                 fontsize=10, color='#e74c3c')

        # Sobre superior en RETURN: mayor entrada
        top_ret = max(caja_info['return_entradas'])

        # Entradas RETURN
        for i, e in enumerate(caja_info['return_entradas']):
            y = 0.38 - i * 0.26
            ax2.add_patch(FancyBboxPatch((0.18, y-0.1), 0.64, 0.16, facecolor='#f8f9fa', edgecolor='#cccccc'))
            ax2.text(0.5, y-0.02, t('entry', lang, e=e), ha='center', va='center',
                     fontweight='bold', fontsize=11)
            ax2.arrow(0.5, y-0.16, 0, -0.06, head_width=0.08, head_length=0.02,
                      fc='#e74c3c', ec='#e74c3c', linewidth=2)

            # Badge "Sobre superior" / "Top envelope" en la entrada marcada
            if e == top_ret:
                ax2.text(0.20, y+0.06, t('top_envelope', lang),
                         ha='left', va='bottom', fontsize=8, fontweight='bold',
                         color='#e74c3c',
                         bbox=dict(boxstyle='round,pad=0.2', facecolor='#fffbe6', edgecolor='#f1c40f'))

    ax2.set_xlim(0, 1); ax2.set_ylim(-0.40, 1); ax2.set_aspect('equal'); ax2.axis('off')

    plt.tight_layout()
    return fig

def _panel_persona(nombre_persona, cajas, rangos, lang):
    """
    Panel por persona en la app. Debajo del orden de sobres
    muestra el n√∫mero calculado del sobre superior (GO y RETURN).
    """
    st.markdown(f"### üë§ {nombre_persona}")
    for c in cajas:
        st.markdown(t('box_label', lang, caja=c['caja'], desc=c['descripcion']))

        fig = _fig_panel_caja(nombre_persona, c, rangos, lang)
        st.pyplot(fig)
        plt.close(fig)

        # Orden de sobres (igual que antes)
        st.markdown(t('envelope_order', lang))
        texto = ""
        if c['go_entradas']:
            if lang == 'es':
                texto += f"{t('go', lang)}: Entradas {', '.join(map(str, c['go_entradas']))} ({t('range_1_to_n', lang, n=rangos)})\n"
            else:
                texto += f"{t('go', lang)}: Entries {', '.join(map(str, c['go_entradas']))} ({t('range_1_to_n', lang, n=rangos)})\n"
        if c['return_entradas']:
            if lang == 'es':
                texto += f"{t('return', lang)}: Entradas {', '.join(map(str, c['return_entradas']))} ({t('range_n_to_1', lang, n=rangos)})"
            else:
                texto += f"{t('return', lang)}: Entries {', '.join(map(str, c['return_entradas']))} ({t('range_n_to_1', lang, n=rangos)})"
        st.text(texto)

        # Pie conciso con el n√∫mero calculado (sin frases gen√©ricas)
        if c['go_entradas']:
            st.caption(f"{t('top_envelope', lang)} (GO): {min(c['go_entradas'])}")
        if c['return_entradas']:
            st.caption(f"{t('top_envelope', lang)} (RETURN): {max(c['return_entradas'])}")

        st.markdown("---")

def _bloque_descargas(grid_fig, asignaciones, rangos, etiqueta, tipo_ensayo, entradas, lang, term_label):
    st.subheader(t('export', lang))

    # Portada para PDFs
    cover_fig = crear_portada_fig(EMPRESA_NOMBRE, TITULO_PORTADA, tipo_ensayo, entradas, rangos, lang, term_label)

    # PNG del Dise√±o/Design
    png_buf = fig_to_png_bytes(grid_fig)
    st.download_button(
        label=t('download_png', lang, term=term_label),
        data=png_buf,
        file_name=f"{term_label.lower()}_{etiqueta}_{rangos}r.png",
        mime="image/png"
    )

    # PDF del Dise√±o/Design (con portada)
    pdf_buf = grid_pdf_with_optional_cover(grid_fig, cover_fig=cover_fig)
    st.download_button(
        label=t('download_pdf', lang, term=term_label),
        data=pdf_buf,
        file_name=f"{term_label.lower()}_{etiqueta}_{rangos}r.pdf",
        mime="application/pdf"
    )

    # CSV del orden de cajas
    df_cajas = cajas_to_dataframe(asignaciones, rangos, tipo_ensayo, lang)
    csv_buf = dataframe_to_csv_bytes(df_cajas)
    st.download_button(
        label=t('download_csv', lang),
        data=csv_buf,
        file_name=f"{'orden_cajas' if lang=='es' else 'box_order'}_{etiqueta}.csv",
        mime="text/csv"
    )

    # PDF de vistas de cajas (con portada; usa el panel con badge)
    boxes_pdf_buf = crear_pdf_vistas_cajas(asignaciones, rangos, tipo_ensayo, lang, cover_fig=cover_fig)
    st.download_button(
        label=t('download_boxes_pdf', lang),
        data=boxes_pdf_buf,
        file_name=f"{'vistas_cajas' if lang=='es' else 'box_views'}_{etiqueta}.pdf",
        mime="application/pdf"
    )

    # PPTX
    pptx_bytes = crear_pptx_bytes(png_buf, df_cajas, lang)
    if pptx_bytes is not None:
        st.download_button(
            label=t('download_pptx', lang),
            data=pptx_bytes,
            file_name=f"planting_{etiqueta}.pptx",
            mime="application/vnd.openxmlformats-officedocument.presentationml.presentation"
        )
    else:
        st.caption(t('pptx_hint', lang))

# ==========================
# Pantallas
# ==========================
def main():
    st.set_page_config(page_title="Planting System Designer / Dise√±ador de Sistema de Siembra", layout="wide")
    set_background(FONDO_IMG_PATH)  # Fondo corporativo fijo

    # Idioma (ES por defecto)
    lang_opt = st.selectbox(LANG['es']['language_label'],
                            [LANG['es']['lang_es'], LANG['en']['lang_en']],
                            index=0)
    lang = 'es' if lang_opt == LANG['es']['lang_es'] else 'en'
    term_label = LANG[lang]['term']  # "Dise√±o" / "Design"

    st.title(t('app_title', lang))
    st.markdown(t('app_subtitle', lang))

    col1, col2, col3 = st.columns(3)
    with col1:
        tipo_ensayo_label = st.selectbox(t('trial_type', lang), [t('srow', lang), t('mrow', lang)])
        tipo_ensayo_code = "SROW" if tipo_ensayo_label == t('srow', lang) else "MROW"
    with col2:
        entradas = st.number_input(t('entries', lang), min_value=1, value=24, step=1)
    with col3:
        rangos = st.number_input(t('ranges', lang), min_value=1, value=28, step=1)

    if st.button(t('generate', lang)):
        if tipo_ensayo_code == "SROW":
            generar_srow(entradas, rangos, lang, term_label)
        else:
            generar_mrow(entradas, rangos, lang, term_label)

def generar_srow(entradas, rangos, lang, term_label):
    st.header(t('header_srow', lang))
    st.subheader(t('overview', lang, term=term_label))
    fig = crear_rejilla_completa("SROW", entradas, rangos, lang, term_label, marcar_inicio=True)
    st.pyplot(fig)

    asignaciones = calcular_cajas_srow(entradas, rangos)

    st.subheader(t('assignments', lang))
    col1, col2 = st.columns(2)
    with col1:
        _panel_persona(t('person_a_rows', lang), asignaciones['A'], rangos, lang)
    with col2:
        _panel_persona(t('person_b_rows', lang), asignaciones['B'], rangos, lang)

    _bloque_descargas(fig, asignaciones, rangos, "SROW", "SROW", entradas, lang, term_label)
    plt.close(fig)

def generar_mrow(entradas, rangos, lang, term_label):
    st.header(t('header_mrow', lang))
    st.subheader(t('overview', lang, term=term_label))
    fig = crear_rejilla_completa("MROW", entradas, rangos, lang, term_label, marcar_inicio=True)
    st.pyplot(fig)

    asignaciones = calcular_cajas_mrow(entradas, rangos)

    st.subheader(t('assignments', lang))
    col1, col2, col3, col4 = st.columns(4)
    with col1:
        _panel_persona(t('person_1_rows', lang), asignaciones['1'], rangos, lang)
    with col2:
        _panel_persona(t('person_2_rows', lang), asignaciones['2'], rangos, lang)
    with col3:
        _panel_persona(t('person_3_rows', lang), asignaciones['3'], rangos, lang)
    with col4:
        _panel_persona(t('person_4_rows', lang), asignaciones['4'], rangos, lang)

    _bloque_descargas(fig, asignaciones, rangos, "MROW", "MROW", entradas, lang, term_label)
    plt.close(fig)

# ==========================
# Entrada
# ==========================
if __name__ == "__main__":
    main()
